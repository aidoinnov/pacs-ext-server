## 요약

*   **도메인 로직 (src/domain):** 시스템의 **'본질'** 에 대한 규칙. **무엇(What)** 인가?
    *   예: "사용자는 이메일과 비밀번호를 가진다."
    *   독립적이고 안정적이며, 잘 변하지 않는 핵심 규칙.

*   **비즈니스 로직 (src/application):** 그 본질을 **'활용'** 하여 특정 기능을 완성하는 **과정**. **어떻게(How)** 할 것인가?
    *   예: "사용자가 가입하면, 이메일이 중복되는지 확인하고 환영 메일을 보낸다."
    *   기능 변경에 따라 유연하게 변하는 절차.

## 핵심 키워드

| 구분 | 도메인 로직 | 비즈니스 로직 |
| :--- | :--- | :--- |
| **연상 단어** | **본질, 규칙, 데이터, 심장** | **활용, 과정, 흐름, 시나리오** |
| **구성 요소** | 엔티티(Entity), 값 객체, 리포지토리 인터페이스 | 유스케이스(Use Case), DTO |
| **위치** | `src/domain` | `src/application` |
| **특징** | 독립적, 안정적 | 도메인에 의존적, 변화에 유연 |

---

# 도메인 로직 vs 비즈니스 로직 상세 설명

'비즈니스 로직'과 '도메인 로직'이라는 용어는 종종 혼용되거나 모호하게 느껴질 수 있습니다. `pacs-ext-server` 프로젝트의 구조에 맞춰 최대한 상세하고 명확하게 설명합니다.

이해를 돕기 위해 간단한 비유를 먼저 들어보겠습니다.

**카페 비유:**
*   **도메인:** '커피 원두', '물', '우유', '컵' 등 카페의 가장 핵심적인 요소들 자체의 **규칙과 상태**.
    *   "원두는 갈아야만 사용할 수 있다."
    *   "물의 온도는 85~95도 사이여야 한다."
    *   "라떼는 우유와 에스프레소로 구성된다."
*   **비즈니스:** '손님이 커피를 주문하고 받아가는 **과정**'.
    *   "손님이 키오스크에서 '아이스 라떼'를 주문한다."
    *   "주문이 들어오면, 바리스타는 컵에 얼음을 채운다."
    *   "우유를 붓고, 에스프레소를 추출해 넣는다."
    *   "완성되면, 주문 번호를 호출하여 손님에게 전달한다."

이 비유처럼, 도메인은 **'무엇(What)'** 에 가깝고, 비즈니스는 **'어떻게(How)'** 에 가깝습니다.

이제 `pacs-ext-server` 프로젝트에 적용해 보겠습니다.

---

### 1. 도메인 로직 (Domain Logic) - `pacs-server/src/domain/`

**"우리 시스템이 다루는 핵심 대상(Domain)의 본질적인 규칙과 데이터"** 를 의미합니다. 시스템의 심장과도 같으며, 외부 요인이나 UI에 관계없이 항상 참이어야 하는 규칙들의 집합입니다.

`pacs-server/src/domain/` 폴더 안의 코드가 바로 이 역할을 합니다.

#### 상세 내역 (주로 `entities` 와 `repositories` 에 정의)

*   **핵심 엔티티(Entity)와 그 상태:**
    *   **`User` (`domain/entities/user.rs`):**
        *   사용자는 반드시 `id`, `email`, `password_hash` 를 가져야 한다.
        *   `email`은 유효한 이메일 형식이어야 한다. (예: `user@example.com`)
        *   `password_hash`는 절대 평문(plain text)이어서는 안 된다.
    *   **`Project` (`domain/entities/project.rs`):**
        *   프로젝트는 `id`, `name`, `owner_id` 를 가져야 한다.
        *   프로젝트 이름(`name`)은 비어있을 수 없다.
    *   **`Permission` (`domain/entities/permission.rs`):**
        *   권한은 `id`, `resource`, `action` (예: `read`, `write`) 등으로 구성된다.

*   **엔티티의 행위(Behavior)와 불변성(Invariants):**
    *   `User` 엔티티 내에 `update_password(new_password)` 라는 함수가 있다면, 이 함수는 새 비밀번호를 해시 처리하는 로직을 포함할 수 있습니다. 이는 `User`의 본질적인 행위입니다.
    *   `Project`의 소유자를 변경하는 `change_owner(new_owner_id)` 함수는 프로젝트의 핵심 로직입니다.

*   **값 객체 (Value Objects):**
    *   `Email` 타입을 따로 만들어, 생성 시점에 이메일 형식이 유효한지 검사하는 로직을 포함할 수 있습니다. `String` 대신 `Email` 타입을 사용하면, 이메일 형식에 대한 규칙이 시스템 전체에 강제됩니다.

*   **리포지토리 인터페이스 (Repository Interface):**
    *   **`UserRepository` (`domain/repositories/user_repository.rs`):**
        *   "사용자를 저장할 수 있어야 한다 (`save`)."
        *   "ID로 사용자를 찾을 수 있어야 한다 (`find_by_id`)."
        *   "이메일로 사용자를 찾을 수 있어야 한다 (`find_by_email`)."
    *   **중요:** 도메인 계층은 **'무엇을 해야 하는지'** 만 정의합니다. 즉, `UserRepository`는 "어떻게" 데이터베이스(PostgreSQL, MySQL 등)에 저장하는지는 전혀 관심 없습니다. 오직 인터페이스(Rust에서는 `trait`)만 정의할 뿐입니다.

**핵심 특징:**
*   **독립성:** 다른 계층(Application, Infrastructure, Presentation)에 의존하지 않습니다. 순수하게 도메인 자체에만 집중합니다.
*   **안정성:** 시스템의 기능이 추가되거나 변경되어도, 도메인 로직은 거의 변하지 않습니다. (예: '회원가입' 방식이 바뀌어도 '사용자'의 기본 정의는 바뀌지 않습니다.)

---

### 2. 비즈니스 로직 (Business Logic) / 애플리케이션 로직 (Application Logic) - `pacs-server/src/application/`

**"도메인 로직을 사용하여, 사용자의 요청이나 특정 시나리오를 해결하는 과정(Process/Workflow)"** 을 의미합니다. 'Use Case'라고도 부릅니다.

`pacs-server/src/application/` 폴더 안의 코드가 이 역할을 합니다.

#### 상세 내역 (주로 `use_cases` 와 `dto` 에 정의)

*   **사용자 시나리오 (Use Cases):**
    *   **`create_user` (`application/use_cases/user_use_case.rs`):**
        1.  사용자로부터 `CreateUserDto`(`application/dto/user_dto.rs`) 를 받습니다. (이메일, 비밀번호 포함)
        2.  `UserRepository`를 사용해, 해당 이메일의 사용자가 이미 존재하는지 확인합니다. **(도메인 기능 활용)**
        3.  만약 존재한다면, "이미 존재하는 이메일입니다" 라는 오류를 반환합니다.
        4.  비밀번호를 해시 처리합니다. **(애플리케이션 수준의 보안 처리)**
        5.  `User` 엔티티를 생성합니다. **(도메인 엔티티 생성)**
        6.  `UserRepository`를 통해 생성된 `User` 엔티티를 저장합니다. **(도메인 기능 활용)**
        7.  성공했다는 의미로, 비밀번호가 제외된 `UserDto`를 반환합니다.
        8.  (만약 필요하다면) 환영 이메일을 발송하거나, 로그를 남깁니다. **(외부 서비스 연동)**

*   **데이터 전송 객체 (DTOs - Data Transfer Objects):**
    *   **`CreateUserDto` (`application/dto/user_dto.rs`):**
        *   API 요청을 통해 들어온 데이터를 `create_user` 유스케이스로 전달하기 위한 구조체입니다.
    *   **`UserDto`:**
        *   유스케이스가 처리 결과를 다시 API 응답으로 내보낼 때 사용하는 구조체입니다. 보통 비밀번호 해시 같은 민감한 정보는 제외됩니다.

*   **외부 서비스와의 상호작용 오케스트레이션:**
    *   하나의 비즈니스 로직이 여러 도메인 엔티티나 외부 서비스를 함께 사용해야 할 때, 그 과정을 총괄 지휘합니다.
    *   예: "프로젝트 생성" 유스케이스
        1.  `Project` 엔티티를 생성하고 저장합니다.
        2.  요청한 사용자를 해당 프로젝트의 '소유자' 역할로 지정합니다. (`Permission` 관련 로직 사용)
        3.  프로젝트 생성에 대한 알림을 보냅니다. (외부 알림 서비스 연동)

**핵심 특징:**
*   **의존성:** 도메인 계층에 의존하여 핵심 규칙을 사용합니다.
*   **프로세스 중심:** '데이터와 규칙'보다는 '과정과 흐름'에 집중합니다.
*   **변경 가능성:** 새로운 기능이 추가되거나 정책이 변경되면 자주 바뀝니다. (예: 회원가입 시 SMS 인증 절차 추가)

---

### 요약 비교표

| 구분 | **도메인 로직 (`src/domain`)** | **비즈니스/애플리케이션 로직 (`src/application`)** |
| :--- | :--- | :--- |
| **관심사** | 시스템의 핵심 데이터, 상태, 그리고 본질적인 규칙 **(What is it?)** | 도메인 규칙을 사용하여 특정 시나리오나 요청을 처리하는 과정 **(How to use it?)** |
| **주요 구성요소** | 엔티티, 값 객체, 리포지토리 인터페이스(`trait`) | 유스케이스(Use Case), DTO(Data Transfer Object) |
| **예시** | "사용자(User)는 유효한 이메일을 가져야 한다." | "사용자가 회원가입을 요청하면, 이메일 중복을 확인하고 비밀번호를 암호화한 후 저장한다." |
| **변경 빈도** | 낮음 (안정적) | 높음 (기능 추가/변경에 따라 변함) |
| **의존성 방향** | **어디에도 의존하지 않음 (독립적)** | **도메인 계층에 의존함** |
