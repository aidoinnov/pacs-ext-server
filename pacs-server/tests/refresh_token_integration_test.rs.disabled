use std::sync::Arc;
use actix_web::{test, App};
use serde_json::json;
use mockito;
use dotenvy;

use pacs_server::presentation::controllers::auth_controller::configure_routes;
use pacs_server::application::use_cases::auth_use_case::AuthUseCase;
use pacs_server::domain::services::auth_service::AuthServiceImpl;
use pacs_server::infrastructure::repositories::UserRepositoryImpl;
use pacs_server::infrastructure::auth::JwtService;
use pacs_server::infrastructure::external::KeycloakClient;
use pacs_server::infrastructure::config::{Settings, KeycloakConfig, JwtConfig};
use pacs_server::application::use_cases::user_registration_use_case::UserRegistrationUseCase;
use pacs_server::infrastructure::services::UserRegistrationServiceImpl;
use pacs_server::application::dto::auth_dto::RefreshTokenRequest;

#[tokio::test]
#[ignore]
async fn test_refresh_token_integration_success() {
    // Load .env file
    dotenvy::dotenv().ok();
    
    // Given
    let mut mock_server = mockito::Server::new_async().await;
    let mock_url = mock_server.url();
    
    // Create database pool using .env settings
    let database_url = std::env::var("APP_DATABASE_URL")
        .expect("APP_DATABASE_URL must be set");
    let pool = sqlx::PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to database");
    
    // Create repositories
    let user_repo = UserRepositoryImpl::new(pool.clone());
    
    // Create Keycloak client with mock URL
    let keycloak_config = KeycloakConfig {
        url: mock_url,
        realm: std::env::var("APP_KEYCLOAK_REALM").expect("APP_KEYCLOAK_REALM must be set"),
        client_id: std::env::var("APP_KEYCLOAK_CLIENT_ID").expect("APP_KEYCLOAK_CLIENT_ID must be set"),
        client_secret: std::env::var("APP_KEYCLOAK_CLIENT_SECRET").expect("APP_KEYCLOAK_CLIENT_SECRET must be set"),
        admin_username: std::env::var("APP_KEYCLOAK_ADMIN_USERNAME").expect("APP_KEYCLOAK_ADMIN_USERNAME must be set"),
        admin_password: std::env::var("APP_KEYCLOAK_ADMIN_PASSWORD").expect("APP_KEYCLOAK_ADMIN_PASSWORD must be set"),
    };
    let keycloak_client = Arc::new(KeycloakClient::new(keycloak_config));
    
    // Create JWT service
    let jwt_config = JwtConfig {
        secret: std::env::var("APP_JWT_SECRET").expect("APP_JWT_SECRET must be set"),
        expiration_hours: std::env::var("APP_JWT_EXPIRATION").expect("APP_JWT_EXPIRATION must be set").parse().unwrap(),
    };
    let jwt_service = JwtService::new(&jwt_config);
    
    // Create auth service
    let auth_service = AuthServiceImpl::new(user_repo, jwt_service, keycloak_client.clone());
    let auth_use_case = Arc::new(AuthUseCase::new(auth_service));
    
    // Create user registration service
    let user_registration_service = UserRegistrationServiceImpl::new(
        pool.clone(),
        (*keycloak_client).clone(),
    );
    let user_registration_use_case = Arc::new(UserRegistrationUseCase::new(user_registration_service));
    
    // Mock Keycloak response
    let expected_keycloak_response = json!({
        "access_token": "new-access-token",
        "refresh_token": "new-refresh-token",
        "expires_in": 3600,
        "refresh_expires_in": 7200,
        "token_type": "Bearer"
    });
    
    let _mock = mock_server
        .mock("POST", "/realms/dcm4che/protocol/openid-connect/token")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(expected_keycloak_response.to_string())
        .create_async()
        .await;
    
    // Create app
    let app = test::init_service(
        App::new().configure(|cfg| configure_routes(cfg, auth_use_case, user_registration_use_case))
    ).await;
    
    // When
    let request_body = RefreshTokenRequest {
        refresh_token: "test-refresh-token".to_string(),
    };
    
    let req = test::TestRequest::post()
        .uri("/api/auth/refresh")
        .set_json(&request_body)
        .to_request();
    
    let resp = test::call_service(&app, req).await;
    
    // Then
    assert_eq!(resp.status(), 200);
    
    let body: serde_json::Value = test::read_body_json(resp).await;
    assert_eq!(body["token"], "new-access-token");
    assert_eq!(body["token_type"], "Bearer");
    assert_eq!(body["expires_in"], 3600);
}

#[tokio::test]
#[ignore]
async fn test_refresh_token_integration_keycloak_error() {
    // Load .env file
    dotenvy::dotenv().ok();
    
    // Given
    let mut mock_server = mockito::Server::new_async().await;
    let mock_url = mock_server.url();
    
    // Create database pool using .env settings
    let database_url = std::env::var("APP_DATABASE_URL")
        .expect("APP_DATABASE_URL must be set");
    let pool = sqlx::PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to database");
    
    // Create repositories
    let user_repo = UserRepositoryImpl::new(pool.clone());
    
    // Create Keycloak client with mock URL
    let keycloak_config = KeycloakConfig {
        url: mock_url,
        realm: std::env::var("APP_KEYCLOAK_REALM").expect("APP_KEYCLOAK_REALM must be set"),
        client_id: std::env::var("APP_KEYCLOAK_CLIENT_ID").expect("APP_KEYCLOAK_CLIENT_ID must be set"),
        client_secret: std::env::var("APP_KEYCLOAK_CLIENT_SECRET").expect("APP_KEYCLOAK_CLIENT_SECRET must be set"),
        admin_username: std::env::var("APP_KEYCLOAK_ADMIN_USERNAME").expect("APP_KEYCLOAK_ADMIN_USERNAME must be set"),
        admin_password: std::env::var("APP_KEYCLOAK_ADMIN_PASSWORD").expect("APP_KEYCLOAK_ADMIN_PASSWORD must be set"),
    };
    let keycloak_client = Arc::new(KeycloakClient::new(keycloak_config));
    
    // Create JWT service
    let jwt_config = JwtConfig {
        secret: std::env::var("APP_JWT_SECRET").expect("APP_JWT_SECRET must be set"),
        expiration_hours: std::env::var("APP_JWT_EXPIRATION").expect("APP_JWT_EXPIRATION must be set").parse().unwrap(),
    };
    let jwt_service = JwtService::new(&jwt_config);
    
    // Create auth service
    let auth_service = AuthServiceImpl::new(user_repo, jwt_service, keycloak_client.clone());
    let auth_use_case = Arc::new(AuthUseCase::new(auth_service));
    
    // Create user registration service
    let user_registration_service = UserRegistrationServiceImpl::new(
        pool.clone(),
        (*keycloak_client).clone(),
    );
    let user_registration_use_case = Arc::new(UserRegistrationUseCase::new(user_registration_service));
    
    // Mock Keycloak error response
    let error_response = json!({
        "error": "invalid_grant",
        "error_description": "Invalid refresh token"
    });
    
    let _mock = mock_server
        .mock("POST", "/realms/dcm4che/protocol/openid-connect/token")
        .with_status(400)
        .with_header("content-type", "application/json")
        .with_body(error_response.to_string())
        .create_async()
        .await;
    
    // Create app
    let app = test::init_service(
        App::new().configure(|cfg| configure_routes(cfg, auth_use_case, user_registration_use_case))
    ).await;
    
    // When
    let request_body = RefreshTokenRequest {
        refresh_token: "invalid-refresh-token".to_string(),
    };
    
    let req = test::TestRequest::post()
        .uri("/api/auth/refresh")
        .set_json(&request_body)
        .to_request();
    
    let resp = test::call_service(&app, req).await;
    
    // Then
    assert_eq!(resp.status(), 401);
    
    let body: serde_json::Value = test::read_body_json(resp).await;
    assert!(body["error"].as_str().unwrap().contains("Token refresh failed"));
}

#[tokio::test]
#[ignore]
async fn test_refresh_token_integration_malformed_response() {
    // Load .env file
    dotenvy::dotenv().ok();
    
    // Given
    let mut mock_server = mockito::Server::new_async().await;
    let mock_url = mock_server.url();
    
    // Create database pool using .env settings
    let database_url = std::env::var("APP_DATABASE_URL")
        .expect("APP_DATABASE_URL must be set");
    let pool = sqlx::PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to database");
    
    // Create repositories
    let user_repo = UserRepositoryImpl::new(pool.clone());
    
    // Create Keycloak client with mock URL
    let keycloak_config = KeycloakConfig {
        url: mock_url,
        realm: std::env::var("APP_KEYCLOAK_REALM").expect("APP_KEYCLOAK_REALM must be set"),
        client_id: std::env::var("APP_KEYCLOAK_CLIENT_ID").expect("APP_KEYCLOAK_CLIENT_ID must be set"),
        client_secret: std::env::var("APP_KEYCLOAK_CLIENT_SECRET").expect("APP_KEYCLOAK_CLIENT_SECRET must be set"),
        admin_username: std::env::var("APP_KEYCLOAK_ADMIN_USERNAME").expect("APP_KEYCLOAK_ADMIN_USERNAME must be set"),
        admin_password: std::env::var("APP_KEYCLOAK_ADMIN_PASSWORD").expect("APP_KEYCLOAK_ADMIN_PASSWORD must be set"),
    };
    let keycloak_client = Arc::new(KeycloakClient::new(keycloak_config));
    
    // Create JWT service
    let jwt_config = JwtConfig {
        secret: std::env::var("APP_JWT_SECRET").expect("APP_JWT_SECRET must be set"),
        expiration_hours: std::env::var("APP_JWT_EXPIRATION").expect("APP_JWT_EXPIRATION must be set").parse().unwrap(),
    };
    let jwt_service = JwtService::new(&jwt_config);
    
    // Create auth service
    let auth_service = AuthServiceImpl::new(user_repo, jwt_service, keycloak_client.clone());
    let auth_use_case = Arc::new(AuthUseCase::new(auth_service));
    
    // Create user registration service
    let user_registration_service = UserRegistrationServiceImpl::new(
        pool.clone(),
        (*keycloak_client).clone(),
    );
    let user_registration_use_case = Arc::new(UserRegistrationUseCase::new(user_registration_service));
    
    // Mock malformed response
    let _mock = mock_server
        .mock("POST", "/realms/dcm4che/protocol/openid-connect/token")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body("invalid json")
        .create_async()
        .await;
    
    // Create app
    let app = test::init_service(
        App::new().configure(|cfg| configure_routes(cfg, auth_use_case, user_registration_use_case))
    ).await;
    
    // When
    let request_body = RefreshTokenRequest {
        refresh_token: "test-refresh-token".to_string(),
    };
    
    let req = test::TestRequest::post()
        .uri("/api/auth/refresh")
        .set_json(&request_body)
        .to_request();
    
    let resp = test::call_service(&app, req).await;
    
    // Then
    assert_eq!(resp.status(), 401);
    
    let body: serde_json::Value = test::read_body_json(resp).await;
    assert!(body["error"].as_str().unwrap().contains("Token refresh failed"));
}

#[tokio::test]
#[ignore]
async fn test_refresh_token_integration_network_timeout() {
    // Load .env file
    dotenvy::dotenv().ok();
    
    // Given
    let settings = Settings::new().expect("Failed to load settings");
    
    // Create database pool using .env settings
    let database_url = std::env::var("APP_DATABASE_URL")
        .expect("APP_DATABASE_URL must be set");
    let pool = sqlx::PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to database");
    
    // Create repositories
    let user_repo = UserRepositoryImpl::new(pool.clone());
    
    // Create Keycloak client with invalid URL to simulate network timeout
    let keycloak_config = KeycloakConfig {
        url: "http://invalid-url:9999".to_string(),
        realm: settings.keycloak.realm.clone(),
        client_id: settings.keycloak.client_id.clone(),
        client_secret: settings.keycloak.client_secret.clone(),
        admin_username: settings.keycloak.admin_username.clone(),
        admin_password: settings.keycloak.admin_password.clone(),
    };
    let keycloak_client = Arc::new(KeycloakClient::new(keycloak_config));
    
    // Create JWT service
    let jwt_service = JwtService::new(&settings.jwt);
    
    // Create auth service
    let auth_service = AuthServiceImpl::new(user_repo, jwt_service, keycloak_client.clone());
    let auth_use_case = Arc::new(AuthUseCase::new(auth_service));
    
    // Create user registration service
    let user_registration_service = UserRegistrationServiceImpl::new(
        pool.clone(),
        (*keycloak_client).clone(),
    );
    let user_registration_use_case = Arc::new(UserRegistrationUseCase::new(user_registration_service));
    
    // Create app
    let app = test::init_service(
        App::new().configure(|cfg| configure_routes(cfg, auth_use_case, user_registration_use_case))
    ).await;
    
    // When
    let request_body = RefreshTokenRequest {
        refresh_token: "test-refresh-token".to_string(),
    };
    
    let req = test::TestRequest::post()
        .uri("/api/auth/refresh")
        .set_json(&request_body)
        .to_request();
    
    let resp = test::call_service(&app, req).await;
    
    // Then
    assert_eq!(resp.status(), 401);
    
    let body: serde_json::Value = test::read_body_json(resp).await;
    assert!(body["error"].as_str().unwrap().contains("Token refresh failed"));
}