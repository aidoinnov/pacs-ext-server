use std::sync::Arc;
use std::time::Instant;
use actix_web::{test, App};
use serde_json::json;
use mockito;
use dotenvy;

use pacs_server::presentation::controllers::auth_controller::configure_routes;
use pacs_server::application::use_cases::auth_use_case::AuthUseCase;
use pacs_server::domain::services::auth_service::AuthServiceImpl;
use pacs_server::infrastructure::repositories::UserRepositoryImpl;
use pacs_server::infrastructure::external::KeycloakClient;
use pacs_server::infrastructure::config::{Settings, KeycloakConfig, JwtConfig};
use pacs_server::infrastructure::auth::JwtService;
use pacs_server::application::dto::auth_dto::{RefreshTokenRequest, RefreshTokenResponse};
use pacs_server::infrastructure::services::UserRegistrationServiceImpl;
use pacs_server::application::use_cases::user_registration_use_case::UserRegistrationUseCase;

#[tokio::test]
#[ignore]
async fn test_refresh_token_performance() {
    // Load .env file
    dotenvy::dotenv().ok();
    
    // Given
    let mut mock_server = mockito::Server::new_async().await;
    let mock_url = mock_server.url();
    
    // Create database pool using .env settings
    let database_url = std::env::var("APP_DATABASE_URL")
        .expect("APP_DATABASE_URL must be set");
    let pool = sqlx::PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to database");
    
    // Create repositories
    let user_repo = UserRepositoryImpl::new(pool.clone());
    
    // Create Keycloak client with mock URL
    let keycloak_config = KeycloakConfig {
        url: mock_url,
        realm: std::env::var("APP_KEYCLOAK_REALM").expect("APP_KEYCLOAK_REALM must be set"),
        client_id: std::env::var("APP_KEYCLOAK_CLIENT_ID").expect("APP_KEYCLOAK_CLIENT_ID must be set"),
        client_secret: std::env::var("APP_KEYCLOAK_CLIENT_SECRET").expect("APP_KEYCLOAK_CLIENT_SECRET must be set"),
        admin_username: std::env::var("APP_KEYCLOAK_ADMIN_USERNAME").expect("APP_KEYCLOAK_ADMIN_USERNAME must be set"),
        admin_password: std::env::var("APP_KEYCLOAK_ADMIN_PASSWORD").expect("APP_KEYCLOAK_ADMIN_PASSWORD must be set"),
    };
    let keycloak_client = Arc::new(KeycloakClient::new(keycloak_config));
    
    // Create JWT service
    let jwt_config = JwtConfig {
        secret: std::env::var("APP_JWT_SECRET").expect("APP_JWT_SECRET must be set"),
        expiration_hours: std::env::var("APP_JWT_EXPIRATION").expect("APP_JWT_EXPIRATION must be set").parse().unwrap(),
    };
    let jwt_service = JwtService::new(&jwt_config);
    
    // Create auth service
    let auth_service = AuthServiceImpl::new(user_repo, jwt_service, keycloak_client.clone());
    let auth_use_case = Arc::new(AuthUseCase::new(auth_service));
    
    // Create user registration service
    let user_registration_service = UserRegistrationServiceImpl::new(
        pool.clone(),
        (*keycloak_client).clone(),
    );
    let user_registration_use_case = Arc::new(UserRegistrationUseCase::new(user_registration_service));
    
    // Mock Keycloak response
    let expected_keycloak_response = json!({
        "access_token": "new-access-token",
        "refresh_token": "new-refresh-token",
        "expires_in": 3600,
        "refresh_expires_in": 7200,
        "token_type": "Bearer"
    });
    
    let _mock = mock_server
        .mock("POST", "/realms/dcm4che/protocol/openid-connect/token")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(expected_keycloak_response.to_string())
        .create_async()
        .await;
    
    // Create app
    let app = test::init_service(
        App::new().configure(|cfg| configure_routes(cfg, auth_use_case, user_registration_use_case))
    ).await;
    
    // When
    let start = Instant::now();
    
    let num_requests = 10;
    let mut success_count = 0;
    
    for i in 0..num_requests {
        let request_body = RefreshTokenRequest {
            refresh_token: format!("test-refresh-token-{}", i),
        };
        
        let req = test::TestRequest::post()
            .uri("/api/auth/refresh")
            .set_json(&request_body)
            .to_request();
        
        let resp = test::call_service(&app, req).await;
        if resp.status() == 200 {
            success_count += 1;
        }
    }
    
    let duration = start.elapsed();
    
    // Then
    assert_eq!(success_count, num_requests, "Not all requests succeeded");
    assert!(duration.as_millis() < 2000, "Requests took too long: {:?}", duration);
    
    println!("{} sequential requests duration: {:?}", num_requests, duration);
    println!("Average time per request: {:?}", duration / num_requests);
}

#[tokio::test]
#[ignore]
async fn test_refresh_token_concurrent_performance() {
    // Load .env file
    dotenvy::dotenv().ok();
    
    // Given
    let mut mock_server = mockito::Server::new_async().await;
    let mock_url = mock_server.url();
    
    // Create database pool using .env settings
    let database_url = std::env::var("APP_DATABASE_URL")
        .expect("APP_DATABASE_URL must be set");
    let pool = sqlx::PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to database");
    
    // Create repositories
    let user_repo = UserRepositoryImpl::new(pool.clone());
    
    // Create Keycloak client with mock URL
    let keycloak_config = KeycloakConfig {
        url: mock_url,
        realm: std::env::var("APP_KEYCLOAK_REALM").expect("APP_KEYCLOAK_REALM must be set"),
        client_id: std::env::var("APP_KEYCLOAK_CLIENT_ID").expect("APP_KEYCLOAK_CLIENT_ID must be set"),
        client_secret: std::env::var("APP_KEYCLOAK_CLIENT_SECRET").expect("APP_KEYCLOAK_CLIENT_SECRET must be set"),
        admin_username: std::env::var("APP_KEYCLOAK_ADMIN_USERNAME").expect("APP_KEYCLOAK_ADMIN_USERNAME must be set"),
        admin_password: std::env::var("APP_KEYCLOAK_ADMIN_PASSWORD").expect("APP_KEYCLOAK_ADMIN_PASSWORD must be set"),
    };
    let keycloak_client = Arc::new(KeycloakClient::new(keycloak_config));
    
    // Create JWT service
    let jwt_config = JwtConfig {
        secret: std::env::var("APP_JWT_SECRET").expect("APP_JWT_SECRET must be set"),
        expiration_hours: std::env::var("APP_JWT_EXPIRATION").expect("APP_JWT_EXPIRATION must be set").parse().unwrap(),
    };
    let jwt_service = JwtService::new(&jwt_config);
    
    // Create auth service
    let auth_service = AuthServiceImpl::new(user_repo, jwt_service, keycloak_client.clone());
    let auth_use_case = Arc::new(AuthUseCase::new(auth_service));
    
    // Create user registration service
    let user_registration_service = UserRegistrationServiceImpl::new(
        pool.clone(),
        (*keycloak_client).clone(),
    );
    let user_registration_use_case = Arc::new(UserRegistrationUseCase::new(user_registration_service));
    
    // Mock Keycloak response
    let expected_keycloak_response = json!({
        "access_token": "new-access-token",
        "refresh_token": "new-refresh-token",
        "expires_in": 3600,
        "refresh_expires_in": 7200,
        "token_type": "Bearer"
    });
    
    let _mock = mock_server
        .mock("POST", "/realms/dcm4che/protocol/openid-connect/token")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(expected_keycloak_response.to_string())
        .create_async()
        .await;
    
    // Create app
    let app = test::init_service(
        App::new().configure(|cfg| configure_routes(cfg, auth_use_case, user_registration_use_case))
    ).await;
    
    // When
    let start = Instant::now();
    
    let num_requests = 5;
    let mut handles = vec![];
    
    for i in 0..num_requests {
        let app = app.clone();
        let handle = tokio::spawn(async move {
            let request_body = RefreshTokenRequest {
                refresh_token: format!("test-refresh-token-{}", i),
            };
            
            let req = test::TestRequest::post()
                .uri("/api/auth/refresh")
                .set_json(&request_body)
                .to_request();
            
            let resp = test::call_service(&app, req).await;
            resp.status() == 200
        });
        handles.push(handle);
    }
    
    let mut success_count = 0;
    for handle in handles {
        if handle.await.unwrap() {
            success_count += 1;
        }
    }
    
    let duration = start.elapsed();
    
    // Then
    assert_eq!(success_count, num_requests, "Not all concurrent requests succeeded");
    assert!(duration.as_millis() < 3000, "Concurrent requests took too long: {:?}", duration);
    
    println!("{} concurrent requests duration: {:?}", num_requests, duration);
    println!("Average time per request: {:?}", duration / num_requests);
}

#[tokio::test]
#[ignore]
async fn test_refresh_token_memory_usage() {
    // Load .env file
    dotenvy::dotenv().ok();
    
    // Given
    let mut mock_server = mockito::Server::new_async().await;
    let mock_url = mock_server.url();
    
    // Create database pool using .env settings
    let database_url = std::env::var("APP_DATABASE_URL")
        .expect("APP_DATABASE_URL must be set");
    let pool = sqlx::PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to database");
    
    // Create repositories
    let user_repo = UserRepositoryImpl::new(pool.clone());
    
    // Create Keycloak client with mock URL
    let keycloak_config = KeycloakConfig {
        url: mock_url,
        realm: std::env::var("APP_KEYCLOAK_REALM").expect("APP_KEYCLOAK_REALM must be set"),
        client_id: std::env::var("APP_KEYCLOAK_CLIENT_ID").expect("APP_KEYCLOAK_CLIENT_ID must be set"),
        client_secret: std::env::var("APP_KEYCLOAK_CLIENT_SECRET").expect("APP_KEYCLOAK_CLIENT_SECRET must be set"),
        admin_username: std::env::var("APP_KEYCLOAK_ADMIN_USERNAME").expect("APP_KEYCLOAK_ADMIN_USERNAME must be set"),
        admin_password: std::env::var("APP_KEYCLOAK_ADMIN_PASSWORD").expect("APP_KEYCLOAK_ADMIN_PASSWORD must be set"),
    };
    let keycloak_client = Arc::new(KeycloakClient::new(keycloak_config));
    
    // Create JWT service
    let jwt_config = JwtConfig {
        secret: std::env::var("APP_JWT_SECRET").expect("APP_JWT_SECRET must be set"),
        expiration_hours: std::env::var("APP_JWT_EXPIRATION").expect("APP_JWT_EXPIRATION must be set").parse().unwrap(),
    };
    let jwt_service = JwtService::new(&jwt_config);
    
    // Create auth service
    let auth_service = AuthServiceImpl::new(user_repo, jwt_service, keycloak_client.clone());
    let auth_use_case = Arc::new(AuthUseCase::new(auth_service));
    
    // Create user registration service
    let user_registration_service = UserRegistrationServiceImpl::new(
        pool.clone(),
        (*keycloak_client).clone(),
    );
    let user_registration_use_case = Arc::new(UserRegistrationUseCase::new(user_registration_service));
    
    // Mock Keycloak response
    let expected_keycloak_response = json!({
        "access_token": "new-access-token",
        "refresh_token": "new-refresh-token",
        "expires_in": 3600,
        "refresh_expires_in": 7200,
        "token_type": "Bearer"
    });
    
    let _mock = mock_server
        .mock("POST", "/realms/dcm4che/protocol/openid-connect/token")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(expected_keycloak_response.to_string())
        .create_async()
        .await;
    
    // Create app
    let app = test::init_service(
        App::new().configure(|cfg| configure_routes(cfg, auth_use_case, user_registration_use_case))
    ).await;
    
    // When
    let start = Instant::now();
    
    let num_requests = 100;
    let mut success_count = 0;
    
    for i in 0..num_requests {
        let request_body = RefreshTokenRequest {
            refresh_token: format!("test-refresh-token-{}", i),
        };
        
        let req = test::TestRequest::post()
            .uri("/api/auth/refresh")
            .set_json(&request_body)
            .to_request();
        
        let resp = test::call_service(&app, req).await;
        if resp.status() == 200 {
            success_count += 1;
        }
        
        // Force garbage collection every 10 requests
        if i % 10 == 0 {
            tokio::task::yield_now().await;
        }
    }
    
    let duration = start.elapsed();
    
    // Then
    assert_eq!(success_count, num_requests, "Not all requests succeeded");
    assert!(duration.as_millis() < 10000, "High volume requests took too long: {:?}", duration);
    
    println!("{} high volume requests duration: {:?}", num_requests, duration);
    println!("Average time per request: {:?}", duration / num_requests);
    println!("Requests per second: {:.2}", num_requests as f64 / duration.as_secs_f64());
}