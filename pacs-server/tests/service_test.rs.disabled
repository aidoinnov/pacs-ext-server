use pacs_server::domain::entities::{RoleScope, NewAnnotation, NewProject, NewPermission};
use chrono::NaiveDate;
use pacs_server::domain::repositories::{
    UserRepository, ProjectRepository, RoleRepository,
    PermissionRepository, AccessLogRepository, AnnotationRepository
};
use pacs_server::domain::services::{
    UserService, UserServiceImpl,
    ProjectService, ProjectServiceImpl,
    PermissionService, PermissionServiceImpl,
    AccessControlService, AccessControlServiceImpl,
    AnnotationService, AnnotationServiceImpl,
};
use pacs_server::infrastructure::repositories::{
    UserRepositoryImpl, ProjectRepositoryImpl, RoleRepositoryImpl,
    PermissionRepositoryImpl, AccessLogRepositoryImpl, AnnotationRepositoryImpl,
};
use sqlx::PgPool;
use uuid::Uuid;
use serde_json::json;

async fn get_test_pool() -> PgPool {
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://admin:admin123@localhost:5432/pacs_db".to_string());

    PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to Postgres")
}

async fn cleanup_test_data(pool: &PgPool) {
    // Foreign key constraint를 비활성화하고 모든 데이터를 삭제
    sqlx::query("SET session_replication_role = replica").execute(pool).await.unwrap();
    
    // 모든 테이블을 순서대로 삭제
    sqlx::query("DELETE FROM annotation_annotation_history").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM annotation_annotation").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM annotation_mask").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM annotation_mask_group").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM security_access_log").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM security_user_project").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM security_project_role").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM security_role_permission").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM security_project_permission").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM security_role_access_condition").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM security_project_access_condition").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM security_user").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM security_project").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM security_role").execute(pool).await.unwrap();
    sqlx::query("DELETE FROM security_permission").execute(pool).await.unwrap();
    
    // Foreign key constraint를 다시 활성화
    sqlx::query("SET session_replication_role = DEFAULT").execute(pool).await.unwrap();
    
    // 시퀀스 리셋 (auto-increment ID 초기화)
    sqlx::query("ALTER SEQUENCE security_user_id_seq RESTART WITH 1").execute(pool).await.unwrap();
    sqlx::query("ALTER SEQUENCE security_project_id_seq RESTART WITH 1").execute(pool).await.unwrap();
    sqlx::query("ALTER SEQUENCE security_role_id_seq RESTART WITH 1").execute(pool).await.unwrap();
    sqlx::query("ALTER SEQUENCE security_permission_id_seq RESTART WITH 1").execute(pool).await.unwrap();
    sqlx::query("ALTER SEQUENCE annotation_annotation_id_seq RESTART WITH 1").execute(pool).await.unwrap();
}

// ========================================
// UserService Tests
// ========================================

#[tokio::test]
#[ignore]
async fn test_user_service_create_user() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);

    let keycloak_id = Uuid::new_v4();
    let user = user_service
        .create_user(
            "testuser".to_string(),
            "test@example.com".to_string(),
            keycloak_id,
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    assert_eq!(user.username, "testuser");
    assert_eq!(user.email, "test@example.com");
    assert_eq!(user.keycloak_id, keycloak_id);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_user_service_duplicate_keycloak_id() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);

    let keycloak_id = Uuid::new_v4();
    user_service
        .create_user(
            "user1".to_string(),
            "user1@example.com".to_string(),
            keycloak_id,
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    // 같은 keycloak_id로 다시 생성 시도
    let result = user_service
        .create_user(
            "user2".to_string(),
            "user2@example.com".to_string(),
            keycloak_id,
            None,
            None,
            None,
            None,
        )
        .await;

    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_user_service_duplicate_username() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);

    user_service
        .create_user(
            "duplicate".to_string(),
            "user1@example.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    // 같은 username으로 다시 생성 시도
    let result = user_service
        .create_user(
            "duplicate".to_string(),
            "user2@example.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await;

    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_user_service_invalid_email() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);

    let result = user_service
        .create_user(
            "testuser".to_string(),
            "invalid-email".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await;

    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_user_service_get_user_by_id() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);

    let created = user_service
        .create_user(
            "testuser".to_string(),
            "test@example.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let found = user_service.get_user_by_id(created.id).await.unwrap();
    assert_eq!(found.id, created.id);
    assert_eq!(found.username, "testuser");

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_user_service_get_user_by_username() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);

    user_service
        .create_user(
            "findme".to_string(),
            "test@example.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let found = user_service.get_user_by_username("findme").await.unwrap();
    assert_eq!(found.username, "findme");

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_user_service_delete_user() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);

    let user = user_service
        .create_user(
            "deleteme".to_string(),
            "delete@example.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    user_service.delete_user(user.id).await.unwrap();

    let result = user_service.get_user_by_id(user.id).await;
    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_user_service_user_exists() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);

    let keycloak_id = Uuid::new_v4();
    user_service
        .create_user(
            "testuser".to_string(),
            "test@example.com".to_string(),
            keycloak_id,
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let exists = user_service.user_exists(keycloak_id).await.unwrap();
    assert!(exists);

    let not_exists = user_service.user_exists(Uuid::new_v4()).await.unwrap();
    assert!(!not_exists);

    cleanup_test_data(&pool).await;
}

// ========================================
// ProjectService Tests
// ========================================

#[tokio::test]
#[ignore]
async fn test_project_service_create_project() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);

    let project = project_service
        .create_project(NewProject {
            name: "Test Project".to_string(),
            description: Some("Description".to_string()),
            sponsor: "Test Sponsor".to_string(),
            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),
            end_date: None,
            auto_complete: false,
        })
        .await
        .unwrap();

    assert_eq!(project.name, "Test Project");
    assert_eq!(project.description, Some("Description".to_string()));
    assert!(project.is_active);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_project_service_duplicate_name() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);

    project_service
        .create_project(NewProject {
            name: "Duplicate".to_string(),
            description: None,
            sponsor: "Test Sponsor".to_string(),
            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),
            end_date: None,
            auto_complete: false,
        })
        .await
        .unwrap();

    let result = project_service
        .create_project(NewProject {
            name: "Duplicate".to_string(),
            description: None,
            sponsor: "Test Sponsor".to_string(),
            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),
            end_date: None,
            auto_complete: false,
        })
        .await;

    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_project_service_empty_name() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);

    let result = project_service
        .create_project(NewProject {
            name: "   ".to_string(),
            description: None,
            sponsor: "Test Sponsor".to_string(),
            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),
            end_date: None,
            auto_complete: false,
        })
        .await;

    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_project_service_name_too_long() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);

    let long_name = "x".repeat(256);
    let result = project_service
        .create_project(NewProject {
            name: long_name,
            description: None,
            sponsor: "Test Sponsor".to_string(),
            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),
            end_date: None,
            auto_complete: false,
        })
        .await;

    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_project_service_get_project() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);

    let created = project_service
        .create_project(NewProject {
            name: "Get Test".to_string(),
            description: None,
            sponsor: "Test Sponsor".to_string(),
            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),
            end_date: None,
            auto_complete: false,
        })
        .await
        .unwrap();

    let found = project_service.get_project(created.id).await.unwrap();
    assert_eq!(found.id, created.id);
    assert_eq!(found.name, "Get Test");

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_project_service_get_project_by_name() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);

    project_service
        .create_project(NewProject {
            name: "FindByName".to_string(),
            description: None,
            sponsor: "Test Sponsor".to_string(),
            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),
            end_date: None,
            auto_complete: false,
        })
        .await
        .unwrap();

    let found = project_service.get_project_by_name("FindByName").await.unwrap();
    assert_eq!(found.name, "FindByName");

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_project_service_get_all_projects() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);

    project_service.create_project(NewProject { name: "Project1".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false }).await.unwrap();
    project_service.create_project(NewProject { name: "Project2".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false }).await.unwrap();
    project_service.create_project(NewProject { name: "Project3".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false }).await.unwrap();

    let all = project_service.get_all_projects().await.unwrap();
    assert!(all.len() >= 3);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_project_service_activate_deactivate() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);

    let project = project_service
        .create_project(NewProject { name: "Toggle".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    assert!(project.is_active);

    let deactivated = project_service.deactivate_project(project.id).await.unwrap();
    assert!(!deactivated.is_active);

    let activated = project_service.activate_project(project.id).await.unwrap();
    assert!(activated.is_active);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_project_service_get_active_projects() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);

    let p1 = project_service.create_project(NewProject { name: "Active1".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false }).await.unwrap();
    let p2 = project_service.create_project(NewProject { name: "Active2".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false }).await.unwrap();
    let p3 = project_service.create_project(NewProject { name: "Inactive".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false }).await.unwrap();

    project_service.deactivate_project(p3.id).await.unwrap();

    let active = project_service.get_active_projects().await.unwrap();
    let active_ids: Vec<i32> = active.iter().map(|p| p.id).collect();

    assert!(active_ids.contains(&p1.id));
    assert!(active_ids.contains(&p2.id));
    assert!(!active_ids.contains(&p3.id));

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_project_service_delete_project() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);

    let project = project_service
        .create_project(NewProject { name: "DeleteMe".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    project_service.delete_project(project.id).await.unwrap();

    let result = project_service.get_project(project.id).await;
    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

// ========================================
// PermissionService Tests
// ========================================

#[tokio::test]
#[ignore]
async fn test_permission_service_create_role() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_service = PermissionServiceImpl::new(permission_repo, role_repo);

    let role = permission_service
        .create_role("Admin".to_string(), RoleScope::Global, Some("Administrator".to_string()))
        .await
        .unwrap();

    assert_eq!(role.name, "Admin");
    assert_eq!(role.description, Some("Administrator".to_string()));
    assert_eq!(role.scope, "GLOBAL");

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_permission_service_duplicate_role_name() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_service = PermissionServiceImpl::new(permission_repo, role_repo);

    permission_service
        .create_role("Duplicate".to_string(), RoleScope::Global, None)
        .await
        .unwrap();

    let result = permission_service
        .create_role("Duplicate".to_string(), RoleScope::Project, None)
        .await;

    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_permission_service_empty_role_name() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_service = PermissionServiceImpl::new(permission_repo, role_repo);

    let result = permission_service
        .create_role("   ".to_string(), RoleScope::Global, None)
        .await;

    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_permission_service_role_name_too_long() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_service = PermissionServiceImpl::new(permission_repo, role_repo);

    let long_name = "x".repeat(101);
    let result = permission_service
        .create_role(long_name, RoleScope::Global, None)
        .await;

    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_permission_service_get_role() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_service = PermissionServiceImpl::new(permission_repo, role_repo);

    let created = permission_service
        .create_role("GetRole".to_string(), RoleScope::Global, None)
        .await
        .unwrap();

    let found = permission_service.get_role(created.id).await.unwrap();
    assert_eq!(found.id, created.id);
    assert_eq!(found.name, "GetRole");

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_permission_service_get_global_roles() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_service = PermissionServiceImpl::new(permission_repo, role_repo);

    let r1 = permission_service.create_role("GlobalRole1".to_string(), RoleScope::Global, None).await.unwrap();
    let r2 = permission_service.create_role("GlobalRole2".to_string(), RoleScope::Global, None).await.unwrap();
    permission_service.create_role("ProjectRole".to_string(), RoleScope::Project, None).await.unwrap();

    let globals = permission_service.get_global_roles().await.unwrap();
    let global_ids: Vec<i32> = globals.iter().map(|r| r.id).collect();

    assert!(global_ids.contains(&r1.id));
    assert!(global_ids.contains(&r2.id));

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_permission_service_get_project_roles() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_service = PermissionServiceImpl::new(permission_repo, role_repo);

    permission_service.create_role("GlobalRole".to_string(), RoleScope::Global, None).await.unwrap();
    let r1 = permission_service.create_role("ProjectRole1".to_string(), RoleScope::Project, None).await.unwrap();
    let r2 = permission_service.create_role("ProjectRole2".to_string(), RoleScope::Project, None).await.unwrap();

    let projects = permission_service.get_project_roles().await.unwrap();
    let project_ids: Vec<i32> = projects.iter().map(|r| r.id).collect();

    assert!(project_ids.contains(&r1.id));
    assert!(project_ids.contains(&r2.id));

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_permission_service_get_roles_by_scope() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_service = PermissionServiceImpl::new(permission_repo, role_repo);

    let r1 = permission_service.create_role("Global1".to_string(), RoleScope::Global, None).await.unwrap();
    let r2 = permission_service.create_role("Project1".to_string(), RoleScope::Project, None).await.unwrap();

    let globals = permission_service.get_roles_by_scope(RoleScope::Global).await.unwrap();
    let global_ids: Vec<i32> = globals.iter().map(|r| r.id).collect();
    assert!(global_ids.contains(&r1.id));

    let projects = permission_service.get_roles_by_scope(RoleScope::Project).await.unwrap();
    let project_ids: Vec<i32> = projects.iter().map(|r| r.id).collect();
    assert!(project_ids.contains(&r2.id));

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_permission_service_validate_permission_exists() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_service = PermissionServiceImpl::new(permission_repo, role_repo);

    // 실제 DB에 있는 권한이 있다고 가정하거나, 테스트용 권한을 먼저 생성해야 함
    // 여기서는 존재하지 않는 권한으로 테스트
    let exists = permission_service
        .validate_permission_exists("nonexistent", "read")
        .await
        .unwrap();

    assert!(!exists);

    cleanup_test_data(&pool).await;
}

// ========================================
// AccessControlService Tests
// ========================================

#[tokio::test]
#[ignore]
async fn test_access_control_service_log_dicom_access() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // 먼저 사용자 생성
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "testuser".to_string(),
            "test@example.com".to_string(),
            Uuid::new_v4(),
            None, None, None, None,
        )
        .await
        .unwrap();

    // 프로젝트 생성
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);
    let project = project_service
        .create_project(NewProject { name: "TestProject".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // AccessControlService 생성
    let access_log_repo = AccessLogRepositoryImpl::new(pool.clone());
    let user_repo2 = UserRepositoryImpl::new(pool.clone());
    let project_repo2 = ProjectRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let access_service = AccessControlServiceImpl::new(access_log_repo, user_repo2, project_repo2, role_repo, permission_repo);

    let log = access_service
        .log_dicom_access(
            user.id,
            Some(project.id),
            "STUDY".to_string(),
            Some("1.2.3.4.5".to_string()),
            None,
            None,
            "VIEW".to_string(),
            "SUCCESS".to_string(),
            Some("192.168.1.1".to_string()),
            Some("WORKSTATION1".to_string()),
        )
        .await
        .unwrap();

    assert_eq!(log.user_id, user.id);
    assert_eq!(log.resource_type, "STUDY");
    assert_eq!(log.action, "VIEW");
    assert_eq!(log.result, "SUCCESS");

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_access_control_service_log_with_invalid_user() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let access_service = AccessControlServiceImpl::new(
        AccessLogRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
        PermissionRepositoryImpl::new(pool.clone())
    );

    let result = access_service
        .log_dicom_access(
            99999,
            None,
            "STUDY".to_string(),
            None,
            None,
            None,
            "VIEW".to_string(),
            "SUCCESS".to_string(),
            None,
            None,
        )
        .await;

    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_access_control_service_get_user_access_logs() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // 사용자 생성
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "loguser".to_string(),
            "log@example.com".to_string(),
            Uuid::new_v4(),
            None, None, None, None,
        )
        .await
        .unwrap();

    // AccessControlService 생성
    let access_service = AccessControlServiceImpl::new(
        AccessLogRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
        PermissionRepositoryImpl::new(pool.clone())
    );

    // 로그 3개 생성
    for i in 0..3 {
        access_service
            .log_dicom_access(
                user.id,
                None,
                "STUDY".to_string(),
                Some(format!("1.2.3.{}", i)),
                None,
                None,
                "VIEW".to_string(),
                "SUCCESS".to_string(),
                None,
                None,
            )
            .await
            .unwrap();
    }

    let logs = access_service.get_user_access_logs(user.id, 10).await.unwrap();
    assert_eq!(logs.len(), 3);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_access_control_service_get_project_access_logs() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // 사용자 및 프로젝트 생성
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "projectuser".to_string(),
            "project@example.com".to_string(),
            Uuid::new_v4(),
            None, None, None, None,
        )
        .await
        .unwrap();

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);
    let project = project_service
        .create_project(NewProject { name: "LogProject".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // AccessControlService
    let access_log_repo = AccessLogRepositoryImpl::new(pool.clone());
    let user_repo2 = UserRepositoryImpl::new(pool.clone());
    let project_repo2 = ProjectRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let access_service = AccessControlServiceImpl::new(access_log_repo, user_repo2, project_repo2, role_repo, permission_repo);

    // 프로젝트 관련 로그 생성
    for _ in 0..2 {
        access_service
            .log_dicom_access(
                user.id,
                Some(project.id),
                "STUDY".to_string(),
                None,
                None,
                None,
                "VIEW".to_string(),
                "SUCCESS".to_string(),
                None,
                None,
            )
            .await
            .unwrap();
    }

    let logs = access_service.get_project_access_logs(project.id, 10).await.unwrap();
    assert_eq!(logs.len(), 2);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_access_control_service_count_user_access() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // 사용자 생성
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "countuser".to_string(),
            "count@example.com".to_string(),
            Uuid::new_v4(),
            None, None, None, None,
        )
        .await
        .unwrap();

    // AccessControlService
    let access_service = AccessControlServiceImpl::new(
        AccessLogRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
        PermissionRepositoryImpl::new(pool.clone())
    );

    // 로그 5개 생성
    for _ in 0..5 {
        access_service
            .log_dicom_access(
                user.id,
                None,
                "STUDY".to_string(),
                None,
                None,
                None,
                "VIEW".to_string(),
                "SUCCESS".to_string(),
                None,
                None,
            )
            .await
            .unwrap();
    }

    let count = access_service.count_user_access(user.id).await.unwrap();
    assert_eq!(count, 5);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_access_control_service_can_access_project() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // 사용자 및 프로젝트 생성
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "accessuser".to_string(),
            "access@example.com".to_string(),
            Uuid::new_v4(),
            None, None, None, None,
        )
        .await
        .unwrap();

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);
    let active_project = project_service
        .create_project(NewProject { name: "ActiveProject".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    let inactive_project = project_service
        .create_project(NewProject { name: "InactiveProject".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    project_service.deactivate_project(inactive_project.id).await.unwrap();

    // 사용자를 두 프로젝트에 추가
    let user_service2 = UserServiceImpl::new(
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone())
    );
    user_service2.add_user_to_project(user.id, active_project.id).await.unwrap();
    user_service2.add_user_to_project(user.id, inactive_project.id).await.unwrap();

    // AccessControlService
    let access_log_repo = AccessLogRepositoryImpl::new(pool.clone());
    let user_repo2 = UserRepositoryImpl::new(pool.clone());
    let project_repo2 = ProjectRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let access_service = AccessControlServiceImpl::new(access_log_repo, user_repo2, project_repo2, role_repo, permission_repo);

    // 활성 프로젝트 접근 가능
    let can_access_active = access_service
        .can_access_project(user.id, active_project.id)
        .await
        .unwrap();
    assert!(can_access_active);

    // 비활성 프로젝트 접근 불가
    let can_access_inactive = access_service
        .can_access_project(user.id, inactive_project.id)
        .await
        .unwrap();
    assert!(!can_access_inactive);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_access_control_service_get_study_access_logs() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // 사용자 생성
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "studyuser".to_string(),
            "study@example.com".to_string(),
            Uuid::new_v4(),
            None, None, None, None,
        )
        .await
        .unwrap();

    // AccessControlService
    let access_service = AccessControlServiceImpl::new(
        AccessLogRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
        PermissionRepositoryImpl::new(pool.clone())
    );

    let study_uid = "1.2.840.113619.2.55.3.123456789";

    // 특정 Study에 대한 로그 생성
    for _ in 0..3 {
        access_service
            .log_dicom_access(
                user.id,
                None,
                "STUDY".to_string(),
                Some(study_uid.to_string()),
                None,
                None,
                "VIEW".to_string(),
                "SUCCESS".to_string(),
                None,
                None,
            )
            .await
            .unwrap();
    }

    let logs = access_service.get_study_access_logs(study_uid, 10).await.unwrap();
    assert_eq!(logs.len(), 3);
    assert_eq!(logs[0].study_uid, Some(study_uid.to_string()));

    cleanup_test_data(&pool).await;
}

// ========================================
// UserService Extension Tests (멤버십 관리)
// ========================================

#[tokio::test]
#[ignore]
async fn test_user_service_add_user_to_project() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);

    // 사용자 생성
    let user = user_service
        .create_user(
            "testuser".to_string(),
            "test@example.com".to_string(),
            Uuid::new_v4(),
            None, None, None, None,
        )
        .await
        .unwrap();

    // 존재하지 않는 프로젝트에 추가 시도 - 에러
    let result = user_service.add_user_to_project(user.id, 99999).await;
    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_user_service_project_membership() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_service = UserServiceImpl::new(
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone())
    );
    let project_service = ProjectServiceImpl::new(
        ProjectRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
    );

    // 사용자와 프로젝트 생성
    let user = user_service
        .create_user(
            "member_test".to_string(),
            "member@example.com".to_string(),
            Uuid::new_v4(),
            None, None, None, None,
        )
        .await
        .unwrap();

    let project = project_service
        .create_project(NewProject { name: "Test Project".to_string(), description: Some("Description".to_string()), sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // 멤버십 확인 (아직 멤버가 아님)
    let is_member = user_service.is_project_member(user.id, project.id).await.unwrap();
    assert!(!is_member);

    // 프로젝트에 사용자 추가
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // 멤버십 확인 (이제 멤버임)
    let is_member = user_service.is_project_member(user.id, project.id).await.unwrap();
    assert!(is_member);

    // 사용자 프로젝트 목록 조회
    let projects = user_service.get_user_projects(user.id).await.unwrap();
    assert_eq!(projects.len(), 1);
    assert_eq!(projects[0].id, project.id);

    // 프로젝트에서 사용자 제거
    user_service.remove_user_from_project(user.id, project.id).await.unwrap();

    // 멤버십 확인 (더 이상 멤버가 아님)
    let is_member = user_service.is_project_member(user.id, project.id).await.unwrap();
    assert!(!is_member);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_user_service_duplicate_membership() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_service = UserServiceImpl::new(
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone())
    );
    let project_service = ProjectServiceImpl::new(
        ProjectRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
    );

    let user = user_service
        .create_user(
            "dup_user".to_string(),
            "dup@example.com".to_string(),
            Uuid::new_v4(),
            None, None, None, None,
        )
        .await
        .unwrap();

    let project = project_service
        .create_project(NewProject { name: "Dup Project".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // 첫 번째 추가 성공
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // 중복 추가 시도 - 에러 발생
    let result = user_service.add_user_to_project(user.id, project.id).await;
    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

// ========================================
// ProjectService Extension Tests (역할/멤버 관리)
// ========================================

#[tokio::test]
#[ignore]
async fn test_project_service_get_members() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let user_service = UserServiceImpl::new(
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone())
    );
    let project_service = ProjectServiceImpl::new(
        ProjectRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone())
    );

    // 프로젝트 생성
    let project = project_service
        .create_project(NewProject { name: "Members Test".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // 사용자 3명 생성 및 추가
    for i in 1..=3 {
        let user = user_service
            .create_user(
                format!("user{}", i),
                format!("user{}@test.com", i),
                Uuid::new_v4(),
                None, None, None, None,
            )
            .await
            .unwrap();

        user_service.add_user_to_project(user.id, project.id).await.unwrap();
    }

    // 멤버 목록 조회
    let members = project_service.get_project_members(project.id).await.unwrap();
    assert_eq!(members.len(), 3);

    // 멤버 수 조회
    let count = project_service.count_project_members(project.id).await.unwrap();
    assert_eq!(count, 3);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_project_service_role_assignment() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let project_service = ProjectServiceImpl::new(
        ProjectRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
    );
    let permission_service = PermissionServiceImpl::new(
        PermissionRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone())
    );

    // 프로젝트와 역할 생성
    let project = project_service
        .create_project(NewProject { name: "Role Test".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    let role = permission_service
        .create_role("Admin".to_string(), RoleScope::Project, Some("Admin role".to_string()))
        .await
        .unwrap();

    // 역할 할당
    project_service.assign_role_to_project(project.id, role.id).await.unwrap();

    // 역할 목록 조회
    let roles = project_service.get_project_roles(project.id).await.unwrap();
    assert_eq!(roles.len(), 1);
    assert_eq!(roles[0].id, role.id);

    // 중복 할당 시도
    let result = project_service.assign_role_to_project(project.id, role.id).await;
    assert!(result.is_err());

    // 역할 제거
    project_service.remove_role_from_project(project.id, role.id).await.unwrap();

    // 역할 목록 조회 (비어있음)
    let roles = project_service.get_project_roles(project.id).await.unwrap();
    assert_eq!(roles.len(), 0);

    cleanup_test_data(&pool).await;
}

// ========================================
// PermissionService Extension Tests (권한 할당)
// ========================================

#[tokio::test]
#[ignore]
async fn test_permission_service_role_permissions() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let permission_service = PermissionServiceImpl::new(
        PermissionRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone())
    );

    // 역할 생성
    let role = permission_service
        .create_role("Viewer".to_string(), RoleScope::Global, None)
        .await
        .unwrap();

    // 권한 생성
    let perm1 = permission_repo.create(NewPermission {
        category: "DICOM".to_string(),
        resource_type: "STUDY".to_string(),
        action: "READ".to_string(),
    }).await.unwrap();

    let perm2 = permission_repo.create(NewPermission {
        category: "DICOM".to_string(),
        resource_type: "SERIES".to_string(),
        action: "READ".to_string(),
    }).await.unwrap();

    // 권한 할당
    permission_service.assign_permission_to_role(role.id, perm1.id).await.unwrap();
    permission_service.assign_permission_to_role(role.id, perm2.id).await.unwrap();

    // 권한 목록 조회
    let permissions = permission_service.get_role_permissions(role.id).await.unwrap();
    assert_eq!(permissions.len(), 2);

    // 중복 할당 시도
    let result = permission_service.assign_permission_to_role(role.id, perm1.id).await;
    assert!(result.is_err());

    // 권한 제거
    permission_service.remove_permission_from_role(role.id, perm1.id).await.unwrap();

    // 권한 목록 조회
    let permissions = permission_service.get_role_permissions(role.id).await.unwrap();
    assert_eq!(permissions.len(), 1);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_permission_service_project_permissions() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());
    let permission_service = PermissionServiceImpl::new(
        PermissionRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
    );
    let project_service = ProjectServiceImpl::new(
        ProjectRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
    );

    // 프로젝트 생성
    let project = project_service
        .create_project(NewProject { name: "Perm Project".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // 권한 생성
    let perm = permission_repo.create(NewPermission {
        category: "DICOM".to_string(),
        resource_type: "STUDY".to_string(),
        action: "WRITE".to_string(),
    }).await.unwrap();

    // 프로젝트에 권한 할당
    permission_service.assign_permission_to_project(project.id, perm.id).await.unwrap();

    // 프로젝트 권한 조회
    let permissions = permission_service.get_project_permissions(project.id).await.unwrap();
    assert_eq!(permissions.len(), 1);
    assert_eq!(permissions[0].id, perm.id);

    // 권한 제거
    permission_service.remove_permission_from_project(project.id, perm.id).await.unwrap();

    // 프로젝트 권한 조회 (비어있음)
    let permissions = permission_service.get_project_permissions(project.id).await.unwrap();
    assert_eq!(permissions.len(), 0);

    cleanup_test_data(&pool).await;
}

// ========================================
// AccessControlService Extension Tests (권한 검증)
// ========================================

#[tokio::test]
#[ignore]
async fn test_access_control_check_permission() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());

    let user_service = UserServiceImpl::new(
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone())
    );
    let project_service = ProjectServiceImpl::new(
        ProjectRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone())
    );
    let permission_service = PermissionServiceImpl::new(
        PermissionRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone())
    );
    let access_service = AccessControlServiceImpl::new(
        AccessLogRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
        PermissionRepositoryImpl::new(pool.clone()),
    );

    // 사용자, 프로젝트, 역할, 권한 생성
    let user = user_service
        .create_user(
            "auth_user".to_string(),
            "auth@test.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let project = project_service
        .create_project(NewProject { name: "Auth Project".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    let role = permission_service
        .create_role("Editor".to_string(), RoleScope::Project, None)
        .await
        .unwrap();

    let perm = permission_repo.create(NewPermission {
        category: "DICOM".to_string(),
        resource_type: "STUDY".to_string(),
        action: "READ".to_string(),
    }).await.unwrap();

    // 역할에 권한 할당
    permission_service.assign_permission_to_role(role.id, perm.id).await.unwrap();

    // 프로젝트에 역할 할당
    project_service.assign_role_to_project(project.id, role.id).await.unwrap();

    // 사용자를 프로젝트에 추가
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // 권한 검증 (성공)
    let has_permission = access_service
        .check_permission(user.id, project.id, "STUDY", "READ")
        .await
        .unwrap();
    assert!(has_permission);

    // 권한 검증 (실패 - 없는 권한)
    let has_permission = access_service
        .check_permission(user.id, project.id, "STUDY", "DELETE")
        .await
        .unwrap();
    assert!(!has_permission);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_access_control_get_user_permissions() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let permission_repo = PermissionRepositoryImpl::new(pool.clone());

    let user_service = UserServiceImpl::new(
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone())
    );
    let project_service = ProjectServiceImpl::new(
        ProjectRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone())
    );
    let permission_service = PermissionServiceImpl::new(
        PermissionRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone())
    );
    let access_service = AccessControlServiceImpl::new(
        AccessLogRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
        PermissionRepositoryImpl::new(pool.clone()),
    );

    // 사용자와 프로젝트 생성
    let user = user_service
        .create_user(
            "perm_user".to_string(),
            "perm@test.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let project = project_service
        .create_project(NewProject { name: "Perm Check Project".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // 역할 생성 및 권한 할당
    let role = permission_service
        .create_role("Reader".to_string(), RoleScope::Project, None)
        .await
        .unwrap();

    // 권한 2개 생성
    let perm1 = permission_repo.create(NewPermission { category: "DICOM".to_string(), resource_type: "STUDY".to_string(), action: "READ".to_string() }).await.unwrap();

    let perm2 = permission_repo.create(NewPermission { category: "DICOM".to_string(), resource_type: "SERIES".to_string(), action: "READ".to_string() }).await.unwrap();

    permission_service.assign_permission_to_role(role.id, perm1.id).await.unwrap();
    permission_service.assign_permission_to_role(role.id, perm2.id).await.unwrap();

    // 프로젝트에 역할 할당
    project_service.assign_role_to_project(project.id, role.id).await.unwrap();

    // 사용자를 프로젝트에 추가
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // 사용자 권한 조회
    let permissions = access_service
        .get_user_permissions(user.id, project.id)
        .await
        .unwrap();

    assert_eq!(permissions.len(), 2);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_access_control_is_project_member() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let access_service = AccessControlServiceImpl::new(
        AccessLogRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
        PermissionRepositoryImpl::new(pool.clone()),
    );

    let user_service = UserServiceImpl::new(
        UserRepositoryImpl::new(pool.clone()),
        ProjectRepositoryImpl::new(pool.clone())
    );
    let project_service = ProjectServiceImpl::new(
        ProjectRepositoryImpl::new(pool.clone()),
        UserRepositoryImpl::new(pool.clone()),
        RoleRepositoryImpl::new(pool.clone()),
    );

    let user = user_service
        .create_user(
            "member_check".to_string(),
            "member@test.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let project = project_service
        .create_project(NewProject { name: "Member Project".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // 멤버가 아님
    let is_member = access_service.is_project_member(user.id, project.id).await.unwrap();
    assert!(!is_member);

    // 멤버 추가
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // 멤버임
    let is_member = access_service.is_project_member(user.id, project.id).await.unwrap();
    assert!(is_member);

    cleanup_test_data(&pool).await;
}

// ========================================
// AnnotationService Tests
// ========================================

#[tokio::test]
#[ignore]
async fn test_annotation_service_create_annotation() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // Create user and project
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "annotation_user".to_string(),
            "annotation@test.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);
    let project = project_service
        .create_project(NewProject { name: "Annotation Project".to_string(), description: Some("Description".to_string()), sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // Add user to project
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // Create annotation service
    let annotation_repo = AnnotationRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let annotation_service = AnnotationServiceImpl::new(annotation_repo, user_repo, project_repo);

    let new_annotation = NewAnnotation {
        project_id: project.id,
        user_id: user.id,
        study_uid: "1.2.840.113619.2.55.3.604688119.868.1234567890.1".to_string(),
        series_uid: Some("1.2.840.113619.2.55.3.604688119.868.1234567890.2".to_string()),
        instance_uid: Some("1.2.840.113619.2.55.3.604688119.868.1234567890.3".to_string()),
        tool_name: "test_tool".to_string(),
        tool_version: Some("1.0.0".to_string()),
        viewer_software: Some("test_viewer".to_string()),
        data: json!({"type": "circle", "x": 100, "y": 200, "radius": 50}),
        description: Some("Test annotation".to_string()),
        is_shared: false,
        measurement_values: None,
    };

    let annotation = annotation_service.create_annotation(new_annotation).await.unwrap();
    assert_eq!(annotation.project_id, project.id);
    assert_eq!(annotation.user_id, user.id);
    assert_eq!(annotation.tool_name, "test_tool");
    assert_eq!(annotation.is_shared, false);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_annotation_service_get_annotation() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // Create user and project
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "get_annotation_user".to_string(),
            "get@test.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);
    let project = project_service
        .create_project(NewProject { name: "Get Annotation Project".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // Add user to project
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // Create annotation service
    let annotation_repo = AnnotationRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let annotation_service = AnnotationServiceImpl::new(annotation_repo, user_repo, project_repo);

    let new_annotation = NewAnnotation {
        project_id: project.id,
        user_id: user.id,
        study_uid: "1.2.3.4.5".to_string(),
        series_uid: Some("1.2.3.4.6".to_string()),
        instance_uid: Some("1.2.3.4.7".to_string()),
        tool_name: "test_tool".to_string(),
        tool_version: Some("1.0.0".to_string()),
        viewer_software: Some("test_viewer".to_string()),
        data: json!({"type": "circle", "x": 100, "y": 200, "radius": 50}),
        description: Some("Test annotation".to_string()),
        is_shared: false,
        measurement_values: None,
    };

    let created = annotation_service.create_annotation(new_annotation).await.unwrap();
    let found = annotation_service.get_annotation_by_id(created.id).await.unwrap();
    assert_eq!(found.id, created.id);
    assert_eq!(found.tool_name, "test_tool");

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_annotation_service_get_annotation_not_found() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    let annotation_repo = AnnotationRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let annotation_service = AnnotationServiceImpl::new(annotation_repo, user_repo, project_repo);

    let result = annotation_service.get_annotation_by_id(99999).await;
    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_annotation_service_update_annotation() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // Create user and project
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "update_annotation_user".to_string(),
            "update@test.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);
    let project = project_service
        .create_project(NewProject { name: "Update Annotation Project".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // Add user to project
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // Create annotation service
    let annotation_repo = AnnotationRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let annotation_service = AnnotationServiceImpl::new(annotation_repo, user_repo, project_repo);

    let new_annotation = NewAnnotation {
        project_id: project.id,
        user_id: user.id,
        study_uid: "1.2.3.4.5".to_string(),
        series_uid: Some("1.2.3.4.6".to_string()),
        instance_uid: Some("1.2.3.4.7".to_string()),
        tool_name: "test_tool".to_string(),
        tool_version: Some("1.0.0".to_string()),
        viewer_software: Some("test_viewer".to_string()),
        data: json!({"type": "circle", "x": 100, "y": 200, "radius": 50}),
        description: Some("Test annotation".to_string()),
        is_shared: false,
        measurement_values: None,
    };

    let created = annotation_service.create_annotation(new_annotation).await.unwrap();

    // Update annotation
    let updated_data = json!({"type": "rectangle", "x": 200, "y": 300, "width": 100, "height": 80});
    let updated = annotation_service.update_annotation(created.id, updated_data.clone(), false).await.unwrap();
    assert_eq!(updated.data, updated_data);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_annotation_service_delete_annotation() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // Create user and project
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "delete_annotation_user".to_string(),
            "delete@test.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);
    let project = project_service
        .create_project(NewProject { name: "Delete Annotation Project".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // Add user to project
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // Create annotation service
    let annotation_repo = AnnotationRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let annotation_service = AnnotationServiceImpl::new(annotation_repo, user_repo, project_repo);

    let new_annotation = NewAnnotation {
        project_id: project.id,
        user_id: user.id,
        study_uid: "1.2.3.4.5".to_string(),
        series_uid: Some("1.2.3.4.6".to_string()),
        instance_uid: Some("1.2.3.4.7".to_string()),
        tool_name: "test_tool".to_string(),
        tool_version: Some("1.0.0".to_string()),
        viewer_software: Some("test_viewer".to_string()),
        data: json!({"type": "circle", "x": 100, "y": 200, "radius": 50}),
        description: Some("Test annotation".to_string()),
        is_shared: false,
        measurement_values: None,
    };

    let created = annotation_service.create_annotation(new_annotation).await.unwrap();
    annotation_service.delete_annotation(created.id).await.unwrap();

    let result = annotation_service.get_annotation_by_id(created.id).await;
    assert!(result.is_err());

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_annotation_service_get_user_annotations() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // Create user and project
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "list_annotation_user".to_string(),
            "list@test.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);
    let project = project_service
        .create_project(NewProject { name: "List Annotation Project".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // Add user to project
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // Create annotation service
    let annotation_repo = AnnotationRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let annotation_service = AnnotationServiceImpl::new(annotation_repo, user_repo, project_repo);

    // Create multiple annotations
    for i in 0..3 {
        let new_annotation = NewAnnotation {
            project_id: project.id,
            user_id: user.id,
            study_uid: format!("1.2.3.4.{}", i),
            series_uid: Some(format!("1.2.3.5.{}", i)),
            instance_uid: Some(format!("1.2.3.6.{}", i)),
            tool_name: "test_tool".to_string(),
            tool_version: Some("1.0.0".to_string()),
            viewer_software: Some("test_viewer".to_string()),
            data: json!({"type": "circle", "x": 100 + i * 10, "y": 200 + i * 10, "radius": 50}),
            description: Some("Test annotation".to_string()),
            is_shared: false,
            measurement_values: None,
        };
        annotation_service.create_annotation(new_annotation).await.unwrap();
    }

    let annotations = annotation_service.get_annotations_by_user(user.id).await.unwrap();
    assert_eq!(annotations.len(), 3);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_annotation_service_get_project_annotations() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // Create user and project
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "project_annotation_user".to_string(),
            "project@test.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);
    let project = project_service
        .create_project(NewProject { name: "Project Annotation Project".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // Add user to project
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // Create annotation service
    let annotation_repo = AnnotationRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let annotation_service = AnnotationServiceImpl::new(annotation_repo, user_repo, project_repo);

    // Create multiple annotations
    for i in 0..2 {
        let new_annotation = NewAnnotation {
            project_id: project.id,
            user_id: user.id,
            study_uid: format!("1.2.3.4.{}", i),
            series_uid: Some(format!("1.2.3.5.{}", i)),
            instance_uid: Some(format!("1.2.3.6.{}", i)),
            tool_name: "test_tool".to_string(),
            tool_version: Some("1.0.0".to_string()),
            viewer_software: Some("test_viewer".to_string()),
            data: json!({"type": "circle", "x": 100 + i * 10, "y": 200 + i * 10, "radius": 50}),
            description: Some("Test annotation".to_string()),
            is_shared: false,
            measurement_values: None,
        };
        annotation_service.create_annotation(new_annotation).await.unwrap();
    }

    let annotations = annotation_service.get_annotations_by_project(project.id).await.unwrap();
    assert_eq!(annotations.len(), 2);

    cleanup_test_data(&pool).await;
}

#[tokio::test]
#[ignore]
async fn test_annotation_service_get_study_annotations() {
    let pool = get_test_pool().await;
    cleanup_test_data(&pool).await;

    // Create user and project
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_service = UserServiceImpl::new(user_repo, project_repo);
    let user = user_service
        .create_user(
            "study_annotation_user".to_string(),
            "study@test.com".to_string(),
            Uuid::new_v4(),
            None,
            None,
            None,
            None,
        )
        .await
        .unwrap();

    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let role_repo = RoleRepositoryImpl::new(pool.clone());
    let project_service = ProjectServiceImpl::new(project_repo, user_repo, role_repo);
    let project = project_service
        .create_project(NewProject { name: "Study Annotation Project".to_string(), description: None, sponsor: "Test Sponsor".to_string(), start_date: NaiveDate::from_ymd_opt(2025,1,1).unwrap(), end_date: None, auto_complete: false })
        .await
        .unwrap();

    // Add user to project
    user_service.add_user_to_project(user.id, project.id).await.unwrap();

    // Create annotation service
    let annotation_repo = AnnotationRepositoryImpl::new(pool.clone());
    let user_repo = UserRepositoryImpl::new(pool.clone());
    let project_repo = ProjectRepositoryImpl::new(pool.clone());
    let annotation_service = AnnotationServiceImpl::new(annotation_repo, user_repo, project_repo);

    let study_uid = "1.2.840.113619.2.55.3.123456789";

    // Create multiple annotations for the same study
    for i in 0..2 {
        let new_annotation = NewAnnotation {
            project_id: project.id,
            user_id: user.id,
            study_uid: study_uid.to_string(),
            series_uid: Some(format!("1.2.3.5.{}", i)),
            instance_uid: Some(format!("1.2.3.6.{}", i)),
            tool_name: "test_tool".to_string(),
            tool_version: Some("1.0.0".to_string()),
            viewer_software: Some("test_viewer".to_string()),
            data: json!({"type": "circle", "x": 100 + i * 10, "y": 200 + i * 10, "radius": 50}),
            description: Some("Test annotation".to_string()),
            is_shared: false,
            measurement_values: None,
        };
        annotation_service.create_annotation(new_annotation).await.unwrap();
    }

    let annotations = annotation_service.get_annotations_by_study(study_uid).await.unwrap();
    assert_eq!(annotations.len(), 2);

    cleanup_test_data(&pool).await;
}
