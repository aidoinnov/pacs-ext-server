# Go vs Rust 서버 성능 비교

## 테스트 환경

- **벤치마크 도구**: wrk
- **테스트 조건**: 4 스레드, 100 동시 연결, 30초 부하 테스트
- **엔드포인트**: `GET /` (Hello, World!)
- **머신**: Apple Silicon (ARM64)

## 성능 측정 결과

### Rust Server (Actix-web)

| 항목 | 값 |
|------|-----|
| **초당 요청 수** | 223,473 req/sec |
| **평균 레이턴시** | 372.47 μs |
| **최대 레이턴시** | 32.78 ms |
| **처리량** | 18.97 MB/sec |
| **30초간 총 요청** | 6,727,046 |

### Go Server (net/http)

| 항목 | 값 |
|------|-----|
| **초당 요청 수** | 111,459 req/sec |
| **평균 레이턴시** | 0.86 ms (860 μs) |
| **최대 레이턴시** | 24.14 ms |
| **처리량** | 13.82 MB/sec |
| **30초간 총 요청** | 3,344,152 |

## 비교 분석

### 성능 차이

- **초당 요청 처리**: Rust가 **2.00배** 더 빠름
- **평균 레이턴시**: Rust가 **2.31배** 더 낮음 (빠름)
- **처리량**: Rust가 **1.37배** 더 높음

### 결론

1. **Rust (Actix-web)**
   - 더 높은 처리량과 낮은 레이턴시
   - CPU 효율적인 비동기 런타임
   - 제로 코스트 추상화로 인한 성능 우위

2. **Go (net/http)**
   - 여전히 매우 우수한 성능 (초당 11만 요청)
   - 더 간단한 코드와 빠른 개발 속도
   - 고루틴 기반의 효율적인 동시성 처리

### 언제 무엇을 사용할까?

- **Rust 추천**: 최고 성능이 중요한 경우, 대규모 트래픽 처리, 저수준 최적화 필요
- **Go 추천**: 빠른 개발과 유지보수, 충분한 성능, 간결한 코드베이스

## 테스트 명령어

### Rust 서버 실행
```bash
cd simple-rust-server
cargo run --release
```

### Go 서버 실행
```bash
cd simple-go-server
source ~/.gvm/scripts/gvm
go run main.go
```

### 벤치마크 실행
```bash
wrk -t4 -c100 -d30s http://localhost:8080/
```
