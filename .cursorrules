# PACS Server AI 어시스턴트 규칙

## 🏗️ 아키텍처 및 디자인 패턴

### Clean Architecture
- 4계층 Clean Architecture 패턴을 따르세요: Domain → Application → Infrastructure → Presentation
- Domain 계층은 다른 모든 계층에서 독립적이어야 합니다
- 의존성은 내부를 향해야 합니다 (Domain 쪽으로)
- 데이터 접근 추상화를 위해 Repository 패턴을 사용하세요
- 비즈니스 로직 캡슐화를 위해 Use Case 패턴을 사용하세요

### 계층별 책임
- **Domain**: 엔티티, Repository 인터페이스, 서비스 인터페이스, 비즈니스 규칙
- **Application**: Use Case, DTO, 서비스 구현체, 비즈니스 로직 오케스트레이션
- **Infrastructure**: 데이터베이스 구현체, 외부 서비스 통합, 설정
- **Presentation**: 컨트롤러, HTTP 핸들러, API 문서화, 요청/응답 처리

## 🦀 Rust 스타일 및 컨벤션

### 네이밍 컨벤션
- **함수 및 변수**: `snake_case`
- **구조체 및 열거형**: `PascalCase`
- **상수**: `SCREAMING_SNAKE_CASE`
- **모듈**: `snake_case`
- **파일**: `snake_case.rs`

### 코드 스타일
- 에러 처리를 위해 항상 `Result<T, E>`를 사용하고, 절대 panic을 사용하지 마세요
- 수동 futures보다 `async/await`를 선호하세요
- nullable 값에는 `Option<T>`를 사용하세요
- DTO와 엔티티 간 변환을 위해 `From` 트레이트를 구현하세요
- 적절한 `#[derive()]` 매크로를 사용하세요 (Debug, Serialize, Deserialize, ToSchema)

### 에러 처리
- `domain::errors`에서 커스텀 에러 타입을 사용하세요
- 에러 변환을 위해 `From` 트레이트를 구현하세요
- 항상 에러를 우아하게 처리하고, 프로덕션 코드에서는 `unwrap()`을 사용하지 마세요
- 에러 전파를 위해 `?` 연산자를 사용하세요

## 📡 API 설계

### RESTful API 원칙
- 적절한 HTTP 메서드를 사용하세요 (GET, POST, PUT, DELETE, PATCH)
- 적절한 HTTP 상태 코드를 사용하세요
- 일관된 JSON 응답 형식을 반환하세요
- 목록 엔드포인트에 적절한 페이지네이션을 구현하세요
- 의미있는 엔드포인트 경로를 사용하세요

### OpenAPI 문서화
- 모든 엔드포인트는 OpenAPI 어노테이션으로 문서화되어야 합니다
- DTO에 `#[derive(ToSchema)]`를 사용하세요
- 모든 필드에 예시와 설명을 제공하세요
- 엔드포인트 문서화를 위해 `utoipa` 매크로를 사용하세요

### 요청/응답 패턴
- 모든 API 통신에 DTO를 사용하세요
- 요청과 응답 DTO를 분리하세요
- 선택적 필드에는 `Option<T>`를 사용하세요
- 적절한 검증 어노테이션을 포함하세요

## 🗄️ 데이터베이스 및 데이터 접근

### SQLx 사용법
- 다단계 작업에는 항상 트랜잭션을 사용하세요
- 보안을 위해 준비된 문을 사용하세요
- 데이터베이스 에러를 적절히 처리하세요
- 연결 풀을 사용하세요
- 적절한 마이그레이션을 구현하세요

### Repository 패턴
- Domain 계층에서 인터페이스를 정의하세요
- Infrastructure 계층에서 구체적인 클래스를 구현하세요
- Repository 인스턴스에 의존성 주입을 사용하세요
- Repository 메서드를 집중적이고 단일 목적으로 유지하세요

## 🔐 보안 및 인증

### 인증
- 사용자 인증을 위해 Keycloak을 사용하세요
- 적절한 JWT 토큰 검증을 구현하세요
- 인증 확인을 위해 미들웨어를 사용하세요
- 요청 확장에 사용자 컨텍스트를 저장하세요

### 권한 부여
- 역할 기반 접근 제어(RBAC)를 구현하세요
- 권한 기반 권한 부여를 사용하세요
- 서비스 계층에서 권한을 확인하세요
- 보안 관련 이벤트를 로그하세요

## 🧪 테스트

### 테스트 구조
- 비즈니스 로직에 대한 단위 테스트
- API 엔드포인트에 대한 통합 테스트
- 데이터 접근에 대한 Repository 테스트
- 통합 테스트에는 테스트 데이터베이스를 사용하세요

### 테스트 명명
- 설명적인 테스트 이름을 사용하세요
- 패턴을 따르세요: `test_[함수명]_[시나리오]_[예상결과]`
- 비동기 테스트에는 `#[tokio::test]`를 사용하세요

## 📁 파일 구성

### 모듈 구조
- 관련 기능을 모듈로 그룹화하세요
- 모듈 정의에는 `mod.rs`를 사용하세요
- 모듈을 집중적이고 응집력 있게 유지하세요
- 깔끔한 공개 API를 위해 re-export를 사용하세요

### Import 구성
- 소스별로 import를 그룹화하세요 (std, external, internal)
- 내부 import에는 절대 경로를 사용하세요
- import를 최소화하고 구체적으로 유지하세요

## 🔧 설정 및 환경

### 설정 관리
- 환경별 설정 파일을 사용하세요
- 설정 관리를 위해 `config` 크레이트를 사용하세요
- 시작 시 설정을 검증하세요
- 민감한 데이터에는 환경 변수를 사용하세요

### 로깅
- 구조화된 로깅을 위해 `tracing`을 사용하세요
- 적절한 레벨에서 로그하세요 (error, warn, info, debug)
- 로그 메시지에 컨텍스트를 포함하세요
- 더 나은 관찰 가능성을 위해 구조화된 로깅을 사용하세요

## 🚀 성능 및 최적화

### 비동기 프로그래밍
- I/O 작업에 async/await를 사용하세요
- 비동기 함수에서 블로킹 작업을 피하세요
- 비동기 코드에서 적절한 에러 처리를 사용하세요
- CPU 집약적인 작업에는 `tokio::spawn` 사용을 고려하세요

### 캐싱
- 적절한 곳에 캐싱을 구현하세요
- 분산 캐싱을 위해 Redis를 사용하세요
- 자주 접근하는 데이터를 캐시하세요
- 캐시 무효화 전략을 구현하세요

## 📝 문서화

### 코드 문서화
- 모든 공개 API를 문서화하세요
- 복잡한 로직에 대해 doc 주석을 사용하세요
- 문서에 예시를 포함하세요
- 문서를 최신 상태로 유지하세요

### API 문서화
- API 문서에 OpenAPI/Swagger를 사용하세요
- 명확한 예시를 제공하세요
- 에러 응답을 문서화하세요
- 인증 요구사항을 포함하세요

### 문서 저장 규칙
- **모든 문서는 Notion에 저장하세요**
- **저장 경로**: 노션 → 외주용역 → 의료 영상 관리 및 뷰어 통합 환경 구축 → 외주 용역 문서 허브
- **문서 유형**: 기술 문서, API 가이드, 아키텍처 문서, 사용자 매뉴얼 등
- **문서 형식**: Markdown 형식으로 작성 후 Notion에 복사
- **버전 관리**: 문서 업데이트 시 Notion에서 버전 히스토리 관리

### 작업 문서 및 칸반 보드 관리
- **작업 문서 작성 요청 시**: 
  - Notion → 외주용역 → 의료 영상 관리 및 뷰어 통합 환경 구축 → 프로젝트 (칸반 보드)
  - 해당 작업에 대한 상세한 작업 문서를 작성하여 칸반 보드에 추가
- **작업 업데이트 요청 시**:
  - 사용자가 제공한 작업 내용을 바탕으로 해당 칸반 보드 항목 업데이트
  - 진행 상황, 완료 내용, 다음 단계 등을 명확히 기록
- **칸반 보드 활용**:
  - 작업 상태별로 적절한 컬럼에 배치 (To Do, In Progress, Done 등)
  - 작업 우선순위 및 담당자 정보 포함
  - 작업 완료 시 상세한 완료 보고서 작성

## 🐳 Docker 및 배포

### 컨테이너화
- 다단계 Docker 빌드를 사용하세요
- 이미지 크기를 최적화하세요
- 적절한 베이스 이미지를 사용하세요
- 헬스 체크를 구현하세요

### 환경 변수
- 설정을 위해 환경 변수를 사용하세요
- 합리적인 기본값을 제공하세요
- 모든 필수 변수를 문서화하세요
- 환경별로 다른 설정을 사용하세요

## 🔍 코드 품질

### 린팅 및 포맷팅
- 린팅을 위해 `cargo clippy`를 사용하세요
- 포맷팅을 위해 `cargo fmt`를 사용하세요
- 모든 clippy 경고를 수정하세요
- 일관된 코드 스타일을 유지하세요

### 의존성
- 의존성을 최신 상태로 유지하세요
- 최소한의 의존성을 사용하세요
- 불필요한 의존성을 피하세요
- 의존성 선택을 문서화하세요

## 🚨 피해야 할 일반적인 안티 패턴

### 하지 말아야 할 것들
- 프로덕션 코드에서 `unwrap()`을 사용하지 마세요
- 에러를 무시하지 마세요
- 불필요하게 `clone()`을 사용하지 마세요
- 컨트롤러에 비즈니스 로직을 섞지 마세요
- 전역 상태를 사용하지 마세요
- 에러 처리를 건너뛰지 마세요
- `&str`로 충분할 때 `String`을 사용하지 마세요

### 대신 이렇게 하세요
- `Result<T, E>`로 적절한 에러 처리를 사용하세요
- 모든 에러 케이스를 명시적으로 처리하세요
- 가능한 한 참조를 사용하세요
- 비즈니스 로직을 서비스/use case 계층에 유지하세요
- 의존성 주입을 사용하세요
- 항상 에러를 우아하게 처리하세요
- 소유권이 필요하지 않을 때는 문자열 슬라이스를 사용하세요

## 📋 코드 리뷰 체크리스트

### 제출 전
- [ ] 모든 테스트가 통과합니다
- [ ] clippy 경고가 없습니다
- [ ] 코드가 적절히 포맷팅되었습니다
- [ ] 에러 처리가 완료되었습니다
- [ ] 문서가 업데이트되었습니다
- [ ] API 문서가 완료되었습니다
- [ ] 보안 고려사항이 해결되었습니다
- [ ] 성능 영향이 고려되었습니다

### 리뷰 집중 영역
- [ ] 아키텍처 준수
- [ ] 에러 처리
- [ ] 보안
- [ ] 성능
- [ ] 테스트 가능성
- [ ] 유지보수성
- [ ] 문서 품질
